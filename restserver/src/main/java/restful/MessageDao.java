package restful;

import java.sql.*;

import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import java.util.*;


/**
 * Created by magnussiwy on 6/21/15.
 */
public class MessageDao {
    GroupDao groupDao = new GroupDao();

    public List<Message> getAllMessages() {
        String SQL = "SELECT * FROM Message";
        List<Map<String,Object>> rows = RDS.getTemplate().queryForList(SQL);
        List<Message> messages = new ArrayList<Message>();
        for (Map row : rows) {
            Message message = new Message((Integer) row.get("messageId"), (Integer) row.get("senderId"), (Timestamp) row.get("dateCreated"),
                    (String) row.get("content"), (Integer) row.get("messageId"), (Integer) row.get("documentId"));
            messages.add(message);
        }
        return messages;
    }

    public Message getMessage(int messageId) {
        String query = "SELECT * FROM Message WHERE messageId = %d";
        String SQL = String.format(query, messageId);
        Message message = RDS.getTemplate().queryForObject(SQL, new MessageMapper());
        return message;
    }

    /**
     * TODO - Note in README that documentId is optional
     */
    public Message sendMessage(int senderId, String[] recipientIds, String content) {
        int[] intRecipientIds = new int[recipientIds.length];
        for (int i = 0; i < recipientIds.length; i++) {
            intRecipientIds[i] = Integer.parseInt(recipientIds[i]);
        }
        int groupId = determineGroupId(intRecipientIds, senderId);
        // Note that documentId needs to be changed for production. Go to the Message class and change it
        int documentId = -1;
        String query = "INSERT INTO Message (senderId, dateCreated, content, groupId, documentId) VALUES (%d, now(), '%s', %d, %d)";
        String SQL = String.format(query, senderId, content, groupId, documentId);
        KeyHolder keyHolder = new GeneratedKeyHolder();

        // Execute Query and return the new messageId generated by the database
        RDS.getTemplate().update(con -> {
            return con.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);
        }, keyHolder);
        int messageId = keyHolder.getKey().intValue();

        // Returns the new Message
        return RDS.getTemplate().queryForObject("SELECT * FROM Message WHERE messageId = ?", new Object[]{ messageId}, new MessageMapper());
    }

    public List<Message> getMessageByMessageId(String messageId) { // return in order by time
        String query = "SELECT * FROM Message WHERE messageId = %d";
        String SQL = String.format(query,messageId);
        List<Map<String,Object>> rows = RDS.getTemplate().queryForList(SQL);
        List<Message> messages = new ArrayList<Message>();
        for (Map row : rows) {
            Message message = new Message((Integer) row.get("messageId"), (Integer) row.get("senderId"), (Timestamp) row.get("dateCreated"),
                    (String) row.get("content"), (Integer) row.get("messageId"), (Integer) row.get("documentId"));
            messages.add(message);
        }
        return messages;
    }

    public void delete(int messageId){
        String query = "DELETE FROM Message WHERE messageId = %d";
        String SQL = String.format(query,messageId);
        RDS.getTemplate().update(SQL);
    }

    /**
     * Helper Function
     * Determines if a group's participants are a unique combination or if a conversation between them already exists,
     * a groupId is returned based on the result.
     */
    public int determineGroupId(int[] recipientIds, int senderId) {
        int groupId = -1;
        Set<Integer> groupParticipants = new HashSet<>();

        // Set containing recipients and sender Id's
        for (int id : recipientIds) {
            groupParticipants.add(id);
        }
        groupParticipants.add(senderId);
        int recipientsLength = groupParticipants.size();

        // MapSqlParameterSource and NamedParameter template needed to pass in array of Id's
        MapSqlParameterSource parameters = new MapSqlParameterSource();
        parameters.addValue("groupParticipants", groupParticipants);
        parameters.addValue("recipientsLength", recipientsLength);
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(RDS.getTemplate().getDataSource());

        // The query returns the groupId that matches the recipients and sender combination. If the combination is new, nothing is returned
        List<Map<String,Object>> rows = namedParameterJdbcTemplate.queryForList(
                "SELECT m.groupId " +
                "FROM GroupParticipant AS m " +
                "GROUP BY m.groupId " +
                "HAVING COUNT(CASE WHEN m.userId in (:groupParticipants) THEN 1 END) = " +
                        "(:recipientsLength) AND COUNT(*) = (:recipientsLength)", parameters);
        List<Integer> rs = new ArrayList<Integer>();
        for (Map row : rows) {
            rs.add((Integer) row.get("groupId"));
        }

        if (rs.size() == 1) {
            // Group already exists - use that id
            groupId = rs.get(0).intValue();
        } else if (rs.size() == 0) {
            // Recipients and sender combination is unique - create a unique groupId
            groupId = groupParticipants.toString().hashCode();
            // Create a new group
            groupDao.createGroupFromMessage(groupId);
            // Update GroupParticipants
            for (int id: recipientIds) {
                groupDao.addUserToGroup(groupId, id);
            }
            groupDao.addUserToGroup(groupId, senderId);

        } else {
            System.err.println("Multiple groups found - database should only have unique group combinations");
        }
        return groupId;

    }
}
